---
layout: post
author: Balázs Pál
title : DS lab - Cosmic Microwave Background - Report 3.
date: 2020-11-11T10:47:00Z+02:00
featured-image: /assets/images/posts/cmb/report_3/CMB_final.webp
featured-image-alt: The final CMB image generated by the Naive method.
---
<b>
In the third and final report of the course Data Science Laboratory, I'm summarizing my work on the project and I'll show in detail, how all my scripts work and how to use them.
</b>

## I. Introduction
In the last week I mostly cleaned up and completely refractored almost all of my codes to finalize them. I've written docstrings for all of my routines, reworked most of my figures and partially completed some extra tasks I set for myself. In this report I would like to finally describe how my codes work and what should someone know about the usage of them.

During the course I've written three different pipelines as my Cosmic Microwave Background radiation project work. Two of them covers the topic of the computer simulation of the CMB radiation, while third one ought to load, process and analyze the publicly available CMB anisotropy maps of the Planck space observatory, but it can be used for the WMAP telescope's measurements as well, since they're both using the same HEALPix standard to encode their datasets. One of the generation algorithm and the latter analyzation routine both uses the HEALPix library, which was implemented in Python under the name `healpy`. The other generation algorithm for the CMB temperature anisotropy map is based on the work of Jeff McMahon and Renée Hložek for the CMB summer school in 2019 of the McMahon Cosmology Laboratory. The link to the original materials can be accessed [here](https://sites.google.com/umich.edu/mcmahoncosmology/cmb-school). These codes are much longer and more complex by magnitudes than the prior ones, but they're completely modular and much more instructive. Using them, one can really gain some insight about how the CMB radiation is measured or what astronomical components it consists of.

## II. Generation method I. -- Using HEALPix
This is the first method for the simulation of the CMB and also the easiest one to implement among the three methods. In this routine we start from a single input angular power spectrum and at the end we're generating a random HEALPix array with completely the same spherical surface indexation (HEALPix) standard, as with eg. the Planck telescope stores their datasets. It can be threated as a fully fledged CMB map from the Planck or WMAP telescope, which can be then loaded and processed using my Planck data procession pipeline in the same way as real datasets are. This routine only consist of two main functions called `load_spectrum()` and `gen_maps()`. Their names are trying to be meaningful. The function `load_spectrum()`
```python
def load_spectrum(fname, lmax=None):
    """
    Loads and arbitrary angular power spectrum from a file.

    Datasets generated with the LAMBDA tool contains only the :math:`D_{l}`
    values, alongside the array of the :math:`l` multipoles and the
    corresponding errors.

    ...
    """
```
simply loads an angular spectrum from a file. This file is considered to be simply a plain-text datafile, where the first column contains the $\ell$ multipoles and the second column contains the $D_{\ell}$ transformed power spectrum values. The $C_{\ell}$ values are calculated and then returned along the $\ell$ and $D_{\ell}$ values. Meanwhile the `gen_maps()` function
```python
def gen_maps(cls, N_SIDE=2048, lmax=None,
             pol=False, pixwin=False, fwhm=5.8e-3, sigma=8.7e-6):
    """
    Generate randomized HEALPix arrays from an input angular power spectrum, using
    the `synfast` subroutine from the `Fortran90` standard implemented in the HEALPix
    library.
    
    ...
    """
```
creates the randomized HEALPix array using the `synfast` routine, which was originally implemented in the `Fortran90` standard and was later ported into the HEALPix library. Today in Python it can be found in the `healpy` package.

## III. CMB analysis -- Using HEALPix
In this part I would like to speak about the analysis pipeline for real observational data. This algorithm is still simple, but contains more subroutines, than the previous one.

All of the Planck CMB maps (regardless of type) are stored in the FITS file format. In every FITS table, there are couple of fields ($\approx 2-7$), each storing a specific HEALPix array. The FITS's header contains more information about the datasets in every field.

In the very first step, this routine using the function `load_HPX()`
```python
def load_HPX(file, field=1):
    """
    Loads a HEALPix array from a given field of an input FITS file.

    ...
    """
```
extracts the HEALPix array stored in a given field from an input FITS file. In my project I've worked particularly with the intensity maps of the temperature anisotropy. These temperature maps of Planck are stored as Kelvin values, so the the function above also converts them to micro Kelvins and returns this converted array as well. This is only a raw, regular 1D HEALPix array yet.

In the next step the function called `get_projection()`
```python
def get_projection(hpx, proj='moll', N_SIDE=2048):
    """
    Projects the input HEALPix dataset on an arbitrary geographical projection,
    which is implemented in the `healpy` package.

    ...
    """
```
interprets the special HEALPix indexing of this array, and maps this on an arbitrary geographical projection. (Note: the function can use only those projections that are implemented in the `healpy` package.) The output of this step is a 2D matrix, which completely encompasses the non-always-rectangular projection itself, as some kind of border or container. Outside of the actual projection, the bad values are handled uniformly by being set to the value `inf`.

Finally the function `plot_cmb()`
```python
def plot_cmb(proj, cmap=None, c_min=None, c_max=None,
             save=False, save_filename='default_name_map'):
    """
    Plots an input image generated by a `healpy.projector` routine and scales the values if needed.
    The routine uses the classic Planck CMB colormap by default to shade pixels on the image.

    ...
    """
```
which generates an image using the original colormap of the Planck CMB temperature maps to shade it and thus making it completely similar to those well-known CMB images.

This part contains two other functions as well, which are used to extract the angular power spectrum of the input HEALPix array and visualize it on a graph, as well as compare it to the theoretical curve, generated the CAMB LAMBDA tool. The first function `cmb_spectrum()`
```python
def cmb_spectrum(hpx, lmax=2500, alm=True):
    """
    Calculates the :math:`a_{lm}` and :math:`C_{l}` parameters using the
    `anafast` subroutine from the Fortran90 standard, up to a given
    :math:`l_{\mathrm{max}}` bandlimit.

    ...
    """
```
uses another `Fortran90` subroutine, called `anafast` to calculate the $C_{\ell}$ angular power spectrum values up to a given $\ell_{\mathrm{max}}$ bandlimit. It optionally returns the $a_{\ell m}$ coefficients in the spherical harmonics expansion of the input function (HEALPix array in this case).

Finally, again, another function called `plot_spectrum()`
```python
def plot_spectrum(ell, Dl, DlTT,
                  save=False, save_filename='default_name_spectrum'):
    """
    Plots the angular power spectrum of the CMB.

    ...
    """
```
visualizes the transformed $D_{\ell}$ values and compares it to the theoretical curve on the same graph.

## IV. Generation method II. -- Naïve method
The second method used for the generation of CMB temperature maps is the last of my routines and it is the most complex as I've already mentioned. The main characteristics of this routine is, that it generates all components of a regular CMB temperature map individually. The base idea behind this particular CMB map generation is to first generate these component individually, then superimpose them over each other to obtain the final, raw intensity map. By "components" I mean the pure CMB temperature anisotropy, the foreground effects and instrumental as well as other type of noises. Foreground effects are consists of point sources with different distributions, while noises are can be attributed to the PSF of the instrumental beam, atmospheric perturbations, observational frequency dependent noise of the instrument (pink noise), or simple, common white noise.

### IV./1. Pure CMB map
The base layer of the simulation is the intensity map of the CMB temperature anisotropy. At the beginning of the simulation, the `make_CMB_I_map()`
```python
def make_CMB_I_map(ell, DlTT,
                   N_x, N_y,
                   X_width, Y_width, pix_size,
                   random_seed=None):
    """
    Makes a realization of a simulated CMB sky map given an input :math:`D_{\ell}` as a function
    of :math:`\ell`. This routine creates a 2D :math:`\ell` and :math:`C_{\ell}` spectrum and
    generates a Gaussian, random realization of the CMB in Fourier space using these. At last the
    map is converted into Image space, which will result us a randomly generated intensity map of
    the CMB temperature anisotropy. 

    ...
    """
```
can be used to construct this randomly generated, pure CMB temperature map using an input angular power spectrum. It should be noted that there are numerous other parameters, which determines the shape, extent and other attributes of the simulated maps, which can be tuned at will by the user. The basic methodology of this function above is that it creates some noise with Gaussian distribution in Fourier space, which parameters are based on the input power spectrum. After that the map is converted to image space and it results a randomized temperature noise map with angular power spectrum close-to-identical to the original input spectrum. This can simply be considered to a randomly generated CMB temperature map, which serves as our base layer for the simulation.

### IV./2. Foreground maps
In reality, the CMB radiation is completely obscured by the overwhelming radiation from objects inside our galaxy, and from other astrophysical structures (eg. other galaxies, AGNs, etc.). Proper filtering pipelines needs to be utilized to separate the foreground effects from the CMB. In this project I've simulated the effect of this component, but in a much more subtle way. In real measurements this enormous effect is attributed to billions of objects, but in this simulations, where individual foreground objects are generated, this huge number can not be replicated. That's why this part of the simulation is more of an "informative" component, than a faithful representation of real measurement data.

There are three type of foreground objects were generated:
1. Points sources with Poisson distribution
2. Points sources with exponential distribution
3. Sunyaev-Zeldovich sources

Point sources can be arise from a number of (mostly) bright astronomical objects, like Active Galactic Nuclei (AGN), Dust Star Forming Galaxies (DSFGs), and a bright tail of lensed DSFGs, as they are listed as examples in the original Ipython Notebooks of Jeff McMahon and Renée Hložek. To simulate a mock image of these sources, we're approximating their population by combining a layer of abundant, but faint sources with a layer of a few, but bright ones.

The first type of point sources represents the faint layer of foreground effects. They're the most abundant, but least intensive objects in the simulation. Because their intensities are generated using the Poisson distribution, their radiation covers only a very narrow, interval in the power spectrum, making them very easy to drop out them during a filtering process. The function `poisson_source_component()`
```python
def poisson_source_component(N_x, N_y,
                             pix_size,
                             number_of_sources, amplitude_of_sources):
    """
    Makes a realization of the naive foreground point source map with Poisson
    distribution.

    ...
    """
```
generates a given number of these faint point sources using the argument `amplitude_of_sources` as a parameter for a Poisson distribution to chose their intensities.

The second type of point sources are those with intensity chosen by an exponential distribution. These objects are generated by the function `exponential_source_component()`
```python
def exponential_source_component(N_x, N_y,
                                 pix_size,
                                 number_of_sources_EX, amplitude_of_sources_EX):
    """
    Makes a realization of the naive foreground point source map with exponential
    distribution.

    ...
    """
```
They're normally much smaller in number, but cover a wider range of temperatures on the power spectrum. Because of this, some of these sources are very intensive on the temperature map compared to the first type of point sources.


```python
def SZ_source_component(N_x, N_y,
                        X_width, Y_width, pix_size,
                        number_of_SZ_clusters, mean_amplitude_of_SZ_clusters,
                        SZ_beta, SZ_theta_core):
    """
    Makes a realization of a naive Sunyaev–Zeldovich effect map.

    ...
    """
```


### IV./3. Noise maps
```python
def convolve_map_with_gaussian_beam(Map,
                                    N_x, N_y,
                                    beam_size_fwhp):
    """
    Convolves a map with a Gaussian beam pattern.

    ...
    """
```

```python
def gen_white_noise(N_x, N_y,
                    pix_size,
                    white_noise_level):
    """
    Makes a white noise map.

    ...
    """
```

```python
def gen_atmospheric_noise(N_x, N_y,
                          X_width, Y_width, pix_size,
                          atmospheric_noise_level):
    """
    Makes an atmospheric noise map.

    ...
    """
```

```python
def gen_one_over_f_noise(N_x, N_y,
                         pix_size,
                         one_over_f_noise_level):
    """
    Generates 1/f noise in the X direction.

    ...
    """
```