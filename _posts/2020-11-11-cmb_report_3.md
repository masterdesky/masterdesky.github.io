---
layout: post
author: Balázs Pál
title : DS lab - Cosmic Microwave Background - Report 3.
date: 2020-11-11T10:47:00Z+02:00
featured-image: +/assets/images/posts/cmb/report_3/.webp
featured-image-alt: Plotting the map of the CMB from FITS tables
---
<b>
In the third and final report of the course Data Science Laboratory, I'm summarizing my work on the project and I'll show in detail, how all my scripts work and how to use them.
</b>

## I. Introduction
In the last week I mostly cleaned up and completely refractored almost all of my codes to finalize them. I've written docstrings for all of my routines, reworked most of my figures and partially completed some extra tasks I set for myself. In this report I would like to finally describe how my codes work and what should someone know about the usage of them.

During the course I've written three different pipelines as my Cosmic Microwave Background radiation project work. Two of them covers the topic of the computer simulation of the CMB radiation, while third one ought to load, process and analyze the publicly available CMB anisotropy maps of the Planck space observatory, but it can be used for the WMAP telescope's measurements as well, since they're both using the same HEALPix standard to encode their datasets. One of the generation algorithm and the latter analyzation routine both uses the HEALPix library, which was implemented in Python under the name `healpy`. The other generation algorithm for the CMB temperature anisotropy map is based on the work of Jeff McMahon and Renée Hložek for the CMB summer school in 2019 of the McMahon Cosmology Laboratory. The link to the original materials can be accessed [here](https://sites.google.com/umich.edu/mcmahoncosmology/cmb-school). These codes are much longer and more complex by magnitudes than the prior ones, but they're completely modular and much more instructive. Using them, one can really gain some insight about how the CMB radiation is measured or what astronomical components it consists of.

## II. Generation method I. -- Using HEALPix
This is the first method for the simulation of the CMB and also the easiest one to implement among the three methods. In this routine we start from a single input angular power spectrum and at the end we're generating a random HEALPix array with completely the same spherical surface indexation (HEALPix) standard, as with eg. the Planck telescope stores their datasets. It can be threated as a fully fledged CMB map from the Planck or WMAP telescope, which can be then loaded and processed using my Planck data procession pipeline in the same way as real datasets are. This routine only consist of two main functions called `load_spectrum()` and `gen_maps()`. Their names are trying to be meaningful. The function `load_spectrum()`
```python
def load_spectrum(fname, lmax=None):
    """
    Loads and arbitrary angular power spectrum from a file.

    Datasets generated with the LAMBDA tool contains only the :math:`D_{l}`
    values, alongside the array of the :math:`l` multipoles and the
    corresponding errors.

    ...
    """
```
simply loads an angular spectrum from a file. This file is considered to be simply a plain-text datafile, where the first column contains the $\ell$ multipoles and the second column contains the $D_{\ell}$ transformed power spectrum values. The $C_{\ell}$ values are calculated and then returned along the $\ell$ and $D_{\ell}$ values. Meanwhile the `gen_maps()` function
```python
def gen_maps(cls, N_SIDE=2048, lmax=None,
             pol=False, pixwin=False, fwhm=5.8e-3, sigma=8.7e-6):
    """
    Generate randomized HEALPix arrays from an input angular power spectrum, using
    the `synfast` subroutine from the `Fortran90` standard implemented in the HEALPix
    library.
    
    ...
    """
```
creates the randomized HEALPix array using the `synfast` routine, which was originally implemented in the `Fortran90` standard and was later ported into the HEALPix library. Today in Python it can be found in the `healpy` package.

## III. CMB analysis -- Using HEALPix
In this part I would like to speak about the analysis pipeline for real observational data. This algorithm is still simple, but contains more subroutines, than the previous one.

All of the Planck CMB maps (regardless of type) are stored in the FITS file format. In every FITS table, there are couple of fields ($\approx 2-7$), each storing a specific HEALPix array. The FITS's header contains more information about the datasets in every field.

In the very first step, this routine using the function `load_HPX()`
```python
def load_HPX(file, field=1):
    """
    Loads a HEALPix array from a given field of an input FITS file.

    ...
    """
```
extracts the HEALPix array stored in a given field from an input FITS file. In my project I've worked particularly with the intensity maps of the temperature anisotropy. These temperature maps of Planck are stored as Kelvin values, so the the function above also converts them to micro Kelvins and returns this converted array as well. This is only a raw, regular 1D HEALPix array yet.

In the next step the function called `get_projection()`
```python
def get_projection(hpx, proj='moll', N_SIDE=2048):
    """
    Projects the input HEALPix dataset on an arbitrary geographical projection,
    which is implemented in the `healpy` package.

    ...
    """
```
interprets the special HEALPix indexing of this array, and maps this on an arbitrary geographical projection. (Note: the function can use only those projections that are implemented in the `healpy` package.) The output of this step is a 2D matrix, which completely encompasses the non-always-rectangular projection itself, as some kind of border or container. Outside of the actual projection, the bad values are handled uniformly by being set to the value `inf`.

Finally the function `plot_cmb()`
```python
def plot_cmb(proj, cmap=None, c_min=None, c_max=None,
             save=False, save_filename='default_name_map'):
    """
    Plots an input image generated by a `healpy.projector` routine and scales the values if needed.
    The routine uses the classic Planck CMB colormap by default to shade pixels on the image.

    ...
    """
```
which generates an image using the original colormap of the Planck CMB temperature maps to shade it and thus making it completely similar to those well-known CMB images.

This part contains two other functions as well, which are used to extract the angular power spectrum of the input HEALPix array and visualize it on a graph, as well as compare it to the theoretical curve, generated the CAMB LAMBDA tool. The first function `cmb_spectrum()`
```python
def cmb_spectrum(hpx, lmax=2500, alm=True):
    """
    Calculates the :math:`a_{lm}` and :math:`C_{l}` parameters using the
    `anafast` subroutine from the Fortran90 standard, up to a given
    :math:`l_{\mathrm{max}}` bandlimit.

    ...
    """
```
uses another `Fortran90` subroutine, called `anafast` to calculate the $C_{\ell}$ angular power spectrum values up to a given $\ell_{\mathrm{max}}$ bandlimit. It optionally returns the $a_{\ell m}$ coefficients in the spherical harmonics expansion of the input function (HEALPix array in this case).

Finally, again, another function called `plot_spectrum()`
```python
def plot_spectrum(ell, Dl, DlTT,
                  save=False, save_filename='default_name_spectrum'):
    """
    Plots the angular power spectrum of the CMB.

    ...
    """
```
visualizes the transformed $D_{\ell}$ values and compares it to the theoretical curve on the same graph.

## IV. Generation method II. -- Naïve method